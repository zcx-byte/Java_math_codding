public class Main {
    public static void main(String[] args) {

        // Размерность системы уравнений (n x n)
        int n = 5; // Матрица 5x5

        // --- Объявление и инициализация массивов ---
        // A - матрица коэффициентов СЛАУ
        double[][] A = {
                {26, 2, 3, 2, 2},
                {4, 23, 3, 2, 1},
                {4, 2, 46, 1, 4},
                {5, 4, 2, 35, 4},
                {1, 5, 3, 5, 49}
        };

        // C - вектор свободных членов (n x 1)
        double[] C = new double[n];

        // X - вектор неизвестных на предыдущей итерации (старое приближение)
        double[] X = new double[n];
        // XX - вектор неизвестных на текущей итерации (новое приближение)
        double[] XX = new double[n];

        // Заполнение вектора C (свободные члены)
        C[0] = 45;
        C[1] = 64;
        C[2] = 152;
        C[3] = 93;
        C[4] = 79;

        // --- Вывод матрицы A ---
        System.out.println("Матрица A:");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                System.out.printf("%10.4f ", A[i][j]); // Форматирование для удобного чтения
            }
            System.out.println();
        }
        System.out.println();

        // --- Вывод вектора C ---
        System.out.println("Вектор C:");
        for (int i = 0; i < n; i++) {
            System.out.printf("%10.4f ", C[i]); // Форматирование для удобного чтения
        }
        System.out.println("\n"); // Переход на новую строку после вывода вектора C


        // --- Инициализация начального приближения X ---
        int k = 0; // Счетчик итераций
        for (int i = 0; i < n; i++) {
            X[i] = 0.0;
        }

        double e = 0.000001;

        // Переменная для подсчета количества неизвестных, изменения которых
        // на текущей итерации удовлетворяют критерию точности.
        int how_many;

        // Основной итерационный цикл
        // Цикл продолжается, пока не все неизвестые не будут найдены с заданной точностью.
        do {
            k = k + 1; // Увеличение счетчика итераций

            // --- Вычисление нового приближения XX ---
            // СЛЕДУЮЩИЙ БЛОК РЕАЛИЗУЕТ МЕТОД ГАУССА — ЗЕЙДЕЛЯ
            for (int i = 0; i < n; i++) {
                // Начинаем вычисление нового значения x_i: сначала присваиваем ему C[i]
                XX[i] = C[i];
                // Затем вычитаем сумму A[i][j] * X[j] для j > i (старое значение)
                for (int j = i + 1; j < n; j++) {
                    XX[i] = XX[i] - A[i][j] * X[j];
                }
                // Затем вычитаем сумму A[i][j] * XX[j] для j < i (новое значение, уже вычисленное на этой итерации)
                for (int j = 0; j < i; j++) {
                    XX[i] = XX[i] - A[i][j] * XX[j];
                }
                // Делим результат на диагональный элемент A[i][i]
                XX[i] = XX[i] / A[i][i];
            }

            how_many = 0;
            for (int i = 0; i < n; i++) {

                if (Math.abs(X[i] - XX[i]) < e) {
                    how_many++;
                }
                // Новое приближение XX[i] становится старым X[i] для следующей итерации
                X[i] = XX[i];
            }

            // Условие продолжения цикла: пока количество "стабилизированных" неизвестных
            // не станет равным общему количеству неизвестных n.
        } while (how_many != n);

        // --- Вывод результата ---
        System.out.println("Решение найдено за " + k + " итераций:");
        for (int i = 0; i < n; i++) {
            System.out.println("X[" + i + "] = " + X[i]);
        }
    }
}