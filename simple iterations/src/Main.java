public class Main {
    public static void main(String[] args) {

        // Размерность системы уравнений (n x n)
        int n = 5; // Матрица 5x5

        // --- Объявление и инициализация массивов ---
        // A - матрица коэффициентов СЛАУ
        double[][] A = {
                {26, 2, 3, 2, 2},
                {4, 23, 3, 2, 1},
                {4, 2, 46, 1, 4},
                {5, 4, 2, 35, 4},
                {1, 5, 3, 5, 49}
        };

        // C - вектор свободных членов (n x 1)
        double[] C = new double[n];
        // X - вектор неизвестных на предыдущей итерации (старое приближение)
        double[] X = new double[n];
        // XX - вектор неизвестных на текущей итерации (новое приближение)
        double[] XX = new double[n];

        // Заполнение вектора C (свободные члены)
        C[0] = 45;
        C[1] = 64;
        C[2] = 152;
        C[3] = 93;
        C[4] = 79;

        // --- Вывод матрицы A для отладки или информации ---
        System.out.println("Матрица A:");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                System.out.printf("%10.4f ", A[i][j]); // Форматирование для удобного чтения
            }
            System.out.println();
        }
        System.out.println();

        // --- Вывод вектора C для отладки или информации ---
        System.out.println("Вектор C:");
        for (int i = 0; i < n; i++) {
            System.out.printf("%10.4f ", C[i]); // Форматирование для удобного чтения
        }
        System.out.println("\n"); // Переход на новую строку после вывода вектора C


        // --- Инициализация начального приближения X ---
        // Начальное приближение часто выбирают нулевым (или другим произвольным).
        int k = 0; // Счетчик итераций
        for (int i = 0; i < n; i++) {
            X[i] = 0.0; // Установка начального приближения
        }

        // Заданная точность (эпсилон) для критерия остановки
        double e = 0.000001;

        // Переменная для подсчета количества неизвестных, изменения которых
        // на текущей итерации удовлетворяют критерию точности.
        int how_many;
        // Основной итерационный цикл
        // Цикл продолжается, пока не все неизвестые не будут найдены с заданной точностью.
        do {
            k = k + 1; // Увеличение счетчика итераций

            // --- Вычисление нового приближения XX ---
            // Этот блок реализует формулу метода простых итераций:
            // x_k^(new) = (C_k - sum_{j!=k} A_{k,j} * x_j^(old)) / A_{k,k}
            for (int i = 0; i < n; i++) {
                // Начинаем вычисление нового значения x_i: сначала присваиваем ему C[i]
                XX[i] = C[i];
                // Затем вычитаем сумму A[i][j] * X[j] для всех j != i
                for (int j = 0; j < n; j++) {
                    if (j != i) { // Пропускаем диагональный элемент (j != i)
                        XX[i] = XX[i] - A[i][j] * X[j]; // X[j] - старое значение
                    }
                }
                // Делим результат на диагональный элемент A[i][i]
                XX[i] = XX[i] / A[i][i];
            }

            // --- Проверка критерия остановки ---
            how_many = 0; // Сброс счетчика на каждой итерации
            for (int i = 0; i < n; i++) {
                // Проверяем, насколько сильно изменилось X[i] по сравнению с XX[i]
                // Если модуль разности меньше заданной точности e, увеличиваем счетчик
                if (Math.abs(X[i] - XX[i]) < e) {
                    how_many++;
                }
                // Новое приближение XX[i] становится старым X[i] для следующей итерации
                X[i] = XX[i];
            }

            // Условие продолжения цикла: пока количество "стабилизированных" неизвестных
            // не станет равным общему количеству неизвестных n.
        } while (how_many != n);

        // --- Вывод результата ---
        System.out.println("Решение найдено за " + k + " итераций:");
        for (int i = 0; i < n; i++) {
            System.out.println("X[" + i + "] = " + X[i]);
        }
    }
}